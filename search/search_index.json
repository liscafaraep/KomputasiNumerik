{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Komputasi Numerik . . Nama : Liscafara Eldyar Pratiwi NIM : 180411100034 Mata Kuliah : Komputasi Numerik 4B Dosen : Mulaab S.Si. M.Kom . . KUMPULAN TUGAS KOMPUTASI NUMERIK . . . Keep learn, learn, and learn. Never give up!:)","title":"Home"},{"location":"#komputasi-numerik","text":". . Nama : Liscafara Eldyar Pratiwi NIM : 180411100034 Mata Kuliah : Komputasi Numerik 4B Dosen : Mulaab S.Si. M.Kom . .","title":"Komputasi Numerik"},{"location":"#kumpulan-tugas-komputasi-numerik","text":". . . Keep learn, learn, and learn. Never give up!:)","title":"KUMPULAN TUGAS KOMPUTASI NUMERIK"},{"location":"tugas1/","text":"Eror (Galat) pada Komputasi Numerik Pengertian Galat Error/Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. Masalah-masalah matematika yang sering kita selesaikan biasanya menggunakan metode analitik atau metode sejati, yaitu suatu metode yang memberikan solusi yang sesungguhnya, karena memiliki galat ( error ) yang bernilai nol. Tetapi penyelesaian dengan menggunakan metode analitik hanya terbatas , tidak selalu bisa diterapkan , maka solusinya masih dapat dicari yaitu dengan menggunakan metode numerik. Pada metode numerik solusinya merupakan hampiran (pendekatan) terhadap solusi sejati. Nilai Galat (Nilai Kesalahan) Besarnya kesalahan atas suatu nilai taksiran dapat dinyatakan secara kuantitatif dan kualitatif. Besarnya kesalahan yang dinyatakan secara kuantitatif disebut Kesalahan Absolut. Besarnya kesalahan yang dinyatakan secara kualitatif disebut dengan Kesalahan Relatif . Absolute Error Kesalahan absolut suatu kuantitas adalah nilai absolut dari selisih antara nilai sebenarnya X dan nilai perkiraan x. Ini dilambangkan dengan : \ud835\udc38\ud835\udc34 =|\ud835\udc4b\u2212 \ud835\udc65| Contoh sederhana : Nilai perkiraan \u1d2b adalah 3.1428571 dan nilai sebenarnya adalah 3.1415926. Temukan Kesalahan absolut \ud835\udc38\ud835\udc34 =|\ud835\udc4b\u2212 \ud835\udc65|= |3.1415926\u2212 3.1428571| \u200b = |\u2212 0 .0 0 1 2 6 4 5| = 0 .0 0 1 2 6 4 5 Relative Error Kesalahan relatif dari suatu kuantitas adalah rasio kesalahan absolutnya terhadap nilai sebenarnya. Ini dilambangkan dengan Er = |(XT-XA)/XT| Contoh (dari soal sebelumnya) : \ud835\udc38R = |3.1415926\u2212 3.1428571/3.1415926 | = | -0.0004025 | = 0.0004025 Persentase relative error: Er = |(XT-XA)/XT|*100% sumber kesalahan dalam komputasi numerik. A. Round off errors Kesalahan jenis ini terjadi akibat proses pembulatan dalam perhitungan. Secara umum, proses pembulatan ada 2 aturan yaitu : - Jika digit yang dibulatkan kurang dari 5, maka tidak terjadi pembulatan. - Sebaliknya, jika lebih dari 5, maka terjadi pembulatan yaitu dengan menambah satu. Contoh sederhananya adalah sebagai berikut : Pada perhitungan nilai x = 6/7, maka nilai x = 0,857142857143. Maka, jika terjadi pembulatan akan diperoleh nilai sebagai berikut : \u00e8 x = 0,86 ( mendekati nilai 2 desimal ). \u00e8 x = 0,8571 ( mendekati nilai 4 desimal ). \u00e8 x = 0,857143 ( mendekati nilai 6 desimal ). \u00e8 x = 0,85714286 ( mendekati nilai 8 desimal ). Dalam proses pembuatan, kesalahan yang timbul akibat pembulatan pada digit ke- n di belakang koma selalu bernilai : Dengan begitu, maka : \u00e8 Untuk x = 0,86 (n = 2), maka Error = | 0,857142857143 \u2013 0,86 | = 0,00285714286 Dengan begitu terbukti bahwa Error \u2264 10-4/2 <-> 0,00285714286 \u2264 0,005. \u00e8 Untuk x = 0,8571 (n = 4), maka Error = | 0,857142857143 \u2013 0,8571 | = 0,000042857143 Dengan begitu terbukti bahwa Error \u2264 10-4/2 <-> Error \u2264 0,00005. \u00e8 Dan seterusnya. ( Anda bisa membuktikan untuk x = 0,857143 dan x = 0,85714286. ) Kesalahan ini biasanya digunakan pada perhitungan data dari hasil percobaan praktikum seperti perhitungan nilai gravitasi dengan teknik perhitungan bandul, menentukan nilai tegangan permukaan, dan lain \u2013 lain. Masing \u2013 masing percobaan biasanya mengulang sebanyak 5 \u2013 10 kali dengan tujuan untuk mengetahui kesalahan mutlak dan mengetahui apakah data yang diperoleh dari hasil praktikum itu tepat, teliti, masih ada kesalahan, atau bahkan error-nya sangat jauh dari perhitungan berdasarkan formula. Teknik ini adalah aprosikmasi kesalahan ( dibahas di bagian blog Aprosikmasi Kesalahan ). Disinilah kegunaan untuk menentukan error suatu perhitungan dengan teknik ini. B. Truncation errors Kesalahan pemotongan biasanya terjadi karena pembuangan suku yang berderajat tinggi. Sebagai contoh untuk menghitung nilai cosinus dapat menggunakan deret Taylor yang dirumuskan di bawah ini : Karena batas akhirnya tak hingga, maka dilakukan pemotongan suku agar perhitungannya lebih sederhana. Misalkan menentukan nilai sin(20) = 0.9129452507276277. Dengan deret Taylor ( hampir sama dengan konsep perhitungan nilai cos ) sampain = 100 akan diperoleh : Dengan begitu nilai errornya adalah C. Range errors Kesalahan yang terjadi akibat nilai hasil komputasi melampaui batas angka yang diperbolehkan dalam komputer. Misalkan dalam penggunaan variabel integer pada proses perhitungan energi benda hitam yang menghasilkan nilai yang tidak tepat bahkan tidak terdefinisi. Untuk kesalahan ini berkaitan dengan batas dalam jangkauan representasi angka. Ini bisa dikatakan bahwa jika hasil perhitungan melebihi jangkauan, maka komputer akan menampilkan hasil yang tidak beraturan ( anggap saja hasil yang diperoleh diatur lagi oleh OS yang kita pakai ). Soal Buat program untuk menentukan jumlah suku agar eror yang tercipta mencapai 0,001 dan cari nilai yang paling mendekati dengan nilai sesungguhnya sesuai selisih tersebut! Program f(x) = e**3x import math x = 1 i = 1 f = 1 #e = (a**i)*x**i #h = abs(f-e) #print(i) while i>0: e = ((2**1)*x**i)/math.factorial(i) f1 = f+e #print(f1) h = abs(f-f1) #ini selisih print(\"Iterasi ke-\"+str(i)) print(\"Selisih =\",h) if h<=0.001: break else: f+=e i+=1 print(\"Jumlah iterasi =\",i) Output yang dihasilkan : Iterasi ke-1 Selisih = 2.0 Iterasi ke-2 Selisih = 1.0 Iterasi ke-3 Selisih = 0.33333333333333304 Iterasi ke-4 Selisih = 0.08333333333333304 Iterasi ke-5 Selisih = 0.016666666666666607 Iterasi ke-6 Selisih = 0.002777777777778212 Iterasi ke-7 Selisih = 0.0003968253968258395 Jumlah iterasi = 7 Referensi : http://algokelvinht.blogspot.com/2016/12/komputer-numerik-galat-atau-error-003.html Ppt : \"Error in Numerical Computations\"","title":"Tugas 1"},{"location":"tugas1/#eror-galat-pada-komputasi-numerik","text":"","title":"Eror (Galat) pada Komputasi Numerik"},{"location":"tugas1/#pengertian-galat","text":"Error/Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. Masalah-masalah matematika yang sering kita selesaikan biasanya menggunakan metode analitik atau metode sejati, yaitu suatu metode yang memberikan solusi yang sesungguhnya, karena memiliki galat ( error ) yang bernilai nol. Tetapi penyelesaian dengan menggunakan metode analitik hanya terbatas , tidak selalu bisa diterapkan , maka solusinya masih dapat dicari yaitu dengan menggunakan metode numerik. Pada metode numerik solusinya merupakan hampiran (pendekatan) terhadap solusi sejati.","title":"Pengertian Galat"},{"location":"tugas1/#nilai-galat-nilai-kesalahan","text":"Besarnya kesalahan atas suatu nilai taksiran dapat dinyatakan secara kuantitatif dan kualitatif. Besarnya kesalahan yang dinyatakan secara kuantitatif disebut Kesalahan Absolut. Besarnya kesalahan yang dinyatakan secara kualitatif disebut dengan Kesalahan Relatif .","title":"Nilai Galat (Nilai Kesalahan)"},{"location":"tugas1/#absolute-error","text":"Kesalahan absolut suatu kuantitas adalah nilai absolut dari selisih antara nilai sebenarnya X dan nilai perkiraan x. Ini dilambangkan dengan : \ud835\udc38\ud835\udc34 =|\ud835\udc4b\u2212 \ud835\udc65| Contoh sederhana : Nilai perkiraan \u1d2b adalah 3.1428571 dan nilai sebenarnya adalah 3.1415926. Temukan Kesalahan absolut \ud835\udc38\ud835\udc34 =|\ud835\udc4b\u2212 \ud835\udc65|= |3.1415926\u2212 3.1428571| \u200b = |\u2212 0 .0 0 1 2 6 4 5| = 0 .0 0 1 2 6 4 5","title":"Absolute Error"},{"location":"tugas1/#relative-error","text":"Kesalahan relatif dari suatu kuantitas adalah rasio kesalahan absolutnya terhadap nilai sebenarnya. Ini dilambangkan dengan Er = |(XT-XA)/XT| Contoh (dari soal sebelumnya) : \ud835\udc38R = |3.1415926\u2212 3.1428571/3.1415926 | = | -0.0004025 | = 0.0004025 Persentase relative error: Er = |(XT-XA)/XT|*100% sumber kesalahan dalam komputasi numerik. A. Round off errors Kesalahan jenis ini terjadi akibat proses pembulatan dalam perhitungan. Secara umum, proses pembulatan ada 2 aturan yaitu : - Jika digit yang dibulatkan kurang dari 5, maka tidak terjadi pembulatan. - Sebaliknya, jika lebih dari 5, maka terjadi pembulatan yaitu dengan menambah satu. Contoh sederhananya adalah sebagai berikut : Pada perhitungan nilai x = 6/7, maka nilai x = 0,857142857143. Maka, jika terjadi pembulatan akan diperoleh nilai sebagai berikut : \u00e8 x = 0,86 ( mendekati nilai 2 desimal ). \u00e8 x = 0,8571 ( mendekati nilai 4 desimal ). \u00e8 x = 0,857143 ( mendekati nilai 6 desimal ). \u00e8 x = 0,85714286 ( mendekati nilai 8 desimal ). Dalam proses pembuatan, kesalahan yang timbul akibat pembulatan pada digit ke- n di belakang koma selalu bernilai : Dengan begitu, maka : \u00e8 Untuk x = 0,86 (n = 2), maka Error = | 0,857142857143 \u2013 0,86 | = 0,00285714286 Dengan begitu terbukti bahwa Error \u2264 10-4/2 <-> 0,00285714286 \u2264 0,005. \u00e8 Untuk x = 0,8571 (n = 4), maka Error = | 0,857142857143 \u2013 0,8571 | = 0,000042857143 Dengan begitu terbukti bahwa Error \u2264 10-4/2 <-> Error \u2264 0,00005. \u00e8 Dan seterusnya. ( Anda bisa membuktikan untuk x = 0,857143 dan x = 0,85714286. ) Kesalahan ini biasanya digunakan pada perhitungan data dari hasil percobaan praktikum seperti perhitungan nilai gravitasi dengan teknik perhitungan bandul, menentukan nilai tegangan permukaan, dan lain \u2013 lain. Masing \u2013 masing percobaan biasanya mengulang sebanyak 5 \u2013 10 kali dengan tujuan untuk mengetahui kesalahan mutlak dan mengetahui apakah data yang diperoleh dari hasil praktikum itu tepat, teliti, masih ada kesalahan, atau bahkan error-nya sangat jauh dari perhitungan berdasarkan formula. Teknik ini adalah aprosikmasi kesalahan ( dibahas di bagian blog Aprosikmasi Kesalahan ). Disinilah kegunaan untuk menentukan error suatu perhitungan dengan teknik ini. B. Truncation errors Kesalahan pemotongan biasanya terjadi karena pembuangan suku yang berderajat tinggi. Sebagai contoh untuk menghitung nilai cosinus dapat menggunakan deret Taylor yang dirumuskan di bawah ini : Karena batas akhirnya tak hingga, maka dilakukan pemotongan suku agar perhitungannya lebih sederhana. Misalkan menentukan nilai sin(20) = 0.9129452507276277. Dengan deret Taylor ( hampir sama dengan konsep perhitungan nilai cos ) sampain = 100 akan diperoleh : Dengan begitu nilai errornya adalah C. Range errors Kesalahan yang terjadi akibat nilai hasil komputasi melampaui batas angka yang diperbolehkan dalam komputer. Misalkan dalam penggunaan variabel integer pada proses perhitungan energi benda hitam yang menghasilkan nilai yang tidak tepat bahkan tidak terdefinisi. Untuk kesalahan ini berkaitan dengan batas dalam jangkauan representasi angka. Ini bisa dikatakan bahwa jika hasil perhitungan melebihi jangkauan, maka komputer akan menampilkan hasil yang tidak beraturan ( anggap saja hasil yang diperoleh diatur lagi oleh OS yang kita pakai ).","title":"Relative Error"},{"location":"tugas1/#soal","text":"Buat program untuk menentukan jumlah suku agar eror yang tercipta mencapai 0,001 dan cari nilai yang paling mendekati dengan nilai sesungguhnya sesuai selisih tersebut!","title":"Soal"},{"location":"tugas1/#program","text":"f(x) = e**3x import math x = 1 i = 1 f = 1 #e = (a**i)*x**i #h = abs(f-e) #print(i) while i>0: e = ((2**1)*x**i)/math.factorial(i) f1 = f+e #print(f1) h = abs(f-f1) #ini selisih print(\"Iterasi ke-\"+str(i)) print(\"Selisih =\",h) if h<=0.001: break else: f+=e i+=1 print(\"Jumlah iterasi =\",i) Output yang dihasilkan : Iterasi ke-1 Selisih = 2.0 Iterasi ke-2 Selisih = 1.0 Iterasi ke-3 Selisih = 0.33333333333333304 Iterasi ke-4 Selisih = 0.08333333333333304 Iterasi ke-5 Selisih = 0.016666666666666607 Iterasi ke-6 Selisih = 0.002777777777778212 Iterasi ke-7 Selisih = 0.0003968253968258395 Jumlah iterasi = 7 Referensi : http://algokelvinht.blogspot.com/2016/12/komputer-numerik-galat-atau-error-003.html Ppt : \"Error in Numerical Computations\"","title":"Program"},{"location":"tugas2/","text":"Tugas 2 Solusi Numerik untuk Persamaan Non Linier Penyelesaian persamaan non linier adalah penentuan akar-akar persamaan non linier. Akar sebuah persamaan f(x) =0 adalah nilai-nilai x yang menyebabkan nilai f(x) sama dengan nol. Akar persamaan f(x) adalah titik potong antara kurva f(x) dan sumbu X. Penyelesaian persamaan nonlinier Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant. Soal Selesaikan persamaan non linier menggunakan metode numerik! $$ x^2-5x+6 $$ Metode Bisection Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma : 1.Definisikan fungsi f(x) yang akan dicari akarnya 2.Tentukan nilai a dan b 3.Tentukan toleransi e dan iterasi maksimum N 4.Hitung f(a) dan f(b) 5.Jika f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan 6.Hitung x = (a+b)/2 7.Hitung f(x) 8.Bila f(x).f(a)<0 maka b = x dan f(b)=f(x), bila tidak maka a=x dan f(a)=f(x) 9.Jika |b-a| iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Contoh program : #Bisection def bis(a,b,n): e = 0.001 fa = a**2-5*a+6 fb = b**2-5*b+6 if fa*fb<0: x = (a+b)/2 fx = x**2-5*x+6 if fa*fx<0: b = x elif fx*fb<0: a = x # print(a) # print(b) if abs(a-b)<e: print(\"Jumlah Iterasi : \",n) print(x) else: n+=1 print(\"iterasi ke-\"+str(n)) bis(a,b,n) else: if fa<fb: a-=0.1 elif fb<fa: b+=0.1 # print(\"a\",a,\"and b\",b) bis(a,b,n) a = float(input(\"Masukkan nilai a : \")) b = float(input(\"Masukkan nilai b : \")) bis(a,b,0) Hasil run program : Masukkan nilai a : 1 Masukkan nilai b : 2.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 iterasi ke-7 iterasi ke-8 iterasi ke-9 iterasi ke-10 Jumlah Iterasi : 10 1.999755859375 Metode Regula Falsi Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurna dari metode bisection Algoritma : Definisikan fungsi f(x) Tentukan batas bawah (a) dan batas atas (b) Tentukan toleransi error e Hitung f(a) dan f(b) Untuk iterasi 1 s/d n > e : c= (f(b).a -f(a).b)/(f(b)-f(a)) Hitung f(c)=f(x) Hitung error = |f(c)| Jika f(c).f(a)<0 maka nilai a tetap ,jika tidak maka a=c dan f(a)=f(c) Akar persamaanya = c Contoh program : #Regula-Falsi def Regfal(a,b,n): e = 0.001 fa = a**2-5*a+6 fb = b**2-5*b+6 # print(fa*fb) if fa*fb<0: n+=1 print(\"iterasi ke-\"+str(n)) # print(\"jalan\") x = ((a*abs(fb))+(b*abs(fa)))/(abs(fa)+abs(fb)) fx = x**2-5*x+6 # print(fx) # print(fb) if fa*fx<0: b = x # elif fb*fx<0: else: a = x # print(a) # print(b) # print(abs(a-b)) if abs(a-b)<e: print(x) else: Regfal(a,b,n) else: if fa<fb: a-=0.1 else: b+=0.1 Regfal(a,b,n) a = float(input(\"Masukkan interval a : \")) b = float(input(\"Masukkan interval b : \")) Regfal(a,b,0) Hasil run program : Masukkan interval a : 1.5 Masukkan interval b : 2.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 iterasi ke-7 iterasi ke-8 iterasi ke-9 iterasi ke-10 iterasi ke-11 iterasi ke-12 iterasi ke-13 iterasi ke-14 iterasi ke-15 iterasi ke-16 iterasi ke-17 iterasi ke-18 iterasi ke-19 iterasi ke-20 iterasi ke-21 iterasi ke-22 iterasi ke-23 iterasi ke-24 iterasi ke-25 iterasi ke-26 iterasi ke-27 iterasi ke-28 iterasi ke-29 iterasi ke-30 iterasi ke-31 iterasi ke-32 2.0 Metode Newton Raphson Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurna dari metode bisection. Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Rumus : $$ x1=x0-(f(x0))/(f\u2032(x0)) $$ Contoh program : #Newton-Raphson x = float(input(\"Masukkan nilai awal x : \")) n = 0 e = 0.001 while n>=0: print(\"iterasi saat X\"+str(n)) fx = x**2-5*x+6 fax = 2*x-5 x1 = x - (fx/fax) if abs(x1-x)<e or n>=100: print(\"Jumlah iterasi : \",n+1) print(x) break else: x=x1 # print(n) n+=1 Hasil run program : Masukkan nilai awal x : 1 iterasi saat X0 iterasi saat X1 iterasi saat X2 iterasi saat X3 iterasi saat X4 Jumlah iterasi : 5 1.9999847409781035 Metode Secant \u25a0 Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). \u25a0 Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. \u25a0 Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen \u25a0 Modifikasi metode Newton Raphson dinamakan metode Secant. Rumus : Algoritma : Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x_0 dan x_1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x_0 ) dan fx_1 sebagai y_0 dan y_1 Untuk iterasi 1 s/d n x_(i+1)= x_i-(f(xi)(x_i \u3016-x\u3017 (i-1)))/(y_i - y (i-1) ) hitung y_(i+1)=\u3016f(x\u3017_(i+1)) Akar persamaan adalah nilai x yang terakhir Contoh program : #Secant def Secant(a,b,n): e = 0.001 fa = a**2-5*a+6 fb = b**2-5*b+6 # if fa*fb<0: x = a-((b-a)/(fb-fa))*fa fx = x**2-5*x+6 n+=1 print(\"iterasi ke-\"+str(n)) if abs(a-b)<e: print(\"Jumlah iterasi :\",n) print(x) else: a=b b=x Secant(a,b,n) # else: # if fa<fb: # a-=0.1 # elif fb<fa: # b+=0.1 # print(\"a\",a,\"and b\",b) # Secant(a,b) a = float(input(\"Masukkan nilai a : \")) b = float(input(\"Masukkan nilai b : \")) n = 0 Secant(a,b,0) Hasil run program : Masukkan nilai a : 1 Masukkan nilai b : 1.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 Jumlah iterasi : 6 1.9999999975499005","title":"Tugas 2"},{"location":"tugas2/#tugas-2","text":"","title":"Tugas 2"},{"location":"tugas2/#solusi-numerik-untuk-persamaan-non-linier","text":"Penyelesaian persamaan non linier adalah penentuan akar-akar persamaan non linier. Akar sebuah persamaan f(x) =0 adalah nilai-nilai x yang menyebabkan nilai f(x) sama dengan nol. Akar persamaan f(x) adalah titik potong antara kurva f(x) dan sumbu X.","title":"Solusi Numerik untuk Persamaan Non Linier"},{"location":"tugas2/#penyelesaian-persamaan-nonlinier","text":"Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant.","title":"Penyelesaian persamaan nonlinier"},{"location":"tugas2/#soal","text":"Selesaikan persamaan non linier menggunakan metode numerik! $$ x^2-5x+6 $$","title":"Soal"},{"location":"tugas2/#metode-bisection","text":"Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma : 1.Definisikan fungsi f(x) yang akan dicari akarnya 2.Tentukan nilai a dan b 3.Tentukan toleransi e dan iterasi maksimum N 4.Hitung f(a) dan f(b) 5.Jika f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan 6.Hitung x = (a+b)/2 7.Hitung f(x) 8.Bila f(x).f(a)<0 maka b = x dan f(b)=f(x), bila tidak maka a=x dan f(a)=f(x) 9.Jika |b-a| iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Contoh program : #Bisection def bis(a,b,n): e = 0.001 fa = a**2-5*a+6 fb = b**2-5*b+6 if fa*fb<0: x = (a+b)/2 fx = x**2-5*x+6 if fa*fx<0: b = x elif fx*fb<0: a = x # print(a) # print(b) if abs(a-b)<e: print(\"Jumlah Iterasi : \",n) print(x) else: n+=1 print(\"iterasi ke-\"+str(n)) bis(a,b,n) else: if fa<fb: a-=0.1 elif fb<fa: b+=0.1 # print(\"a\",a,\"and b\",b) bis(a,b,n) a = float(input(\"Masukkan nilai a : \")) b = float(input(\"Masukkan nilai b : \")) bis(a,b,0) Hasil run program : Masukkan nilai a : 1 Masukkan nilai b : 2.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 iterasi ke-7 iterasi ke-8 iterasi ke-9 iterasi ke-10 Jumlah Iterasi : 10 1.999755859375","title":"Metode Bisection"},{"location":"tugas2/#metode-regula-falsi","text":"Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurna dari metode bisection Algoritma : Definisikan fungsi f(x) Tentukan batas bawah (a) dan batas atas (b) Tentukan toleransi error e Hitung f(a) dan f(b) Untuk iterasi 1 s/d n > e : c= (f(b).a -f(a).b)/(f(b)-f(a)) Hitung f(c)=f(x) Hitung error = |f(c)| Jika f(c).f(a)<0 maka nilai a tetap ,jika tidak maka a=c dan f(a)=f(c) Akar persamaanya = c Contoh program : #Regula-Falsi def Regfal(a,b,n): e = 0.001 fa = a**2-5*a+6 fb = b**2-5*b+6 # print(fa*fb) if fa*fb<0: n+=1 print(\"iterasi ke-\"+str(n)) # print(\"jalan\") x = ((a*abs(fb))+(b*abs(fa)))/(abs(fa)+abs(fb)) fx = x**2-5*x+6 # print(fx) # print(fb) if fa*fx<0: b = x # elif fb*fx<0: else: a = x # print(a) # print(b) # print(abs(a-b)) if abs(a-b)<e: print(x) else: Regfal(a,b,n) else: if fa<fb: a-=0.1 else: b+=0.1 Regfal(a,b,n) a = float(input(\"Masukkan interval a : \")) b = float(input(\"Masukkan interval b : \")) Regfal(a,b,0) Hasil run program : Masukkan interval a : 1.5 Masukkan interval b : 2.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 iterasi ke-7 iterasi ke-8 iterasi ke-9 iterasi ke-10 iterasi ke-11 iterasi ke-12 iterasi ke-13 iterasi ke-14 iterasi ke-15 iterasi ke-16 iterasi ke-17 iterasi ke-18 iterasi ke-19 iterasi ke-20 iterasi ke-21 iterasi ke-22 iterasi ke-23 iterasi ke-24 iterasi ke-25 iterasi ke-26 iterasi ke-27 iterasi ke-28 iterasi ke-29 iterasi ke-30 iterasi ke-31 iterasi ke-32 2.0","title":"Metode Regula Falsi"},{"location":"tugas2/#metode-newton-raphson","text":"Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurna dari metode bisection. Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Rumus : $$ x1=x0-(f(x0))/(f\u2032(x0)) $$ Contoh program : #Newton-Raphson x = float(input(\"Masukkan nilai awal x : \")) n = 0 e = 0.001 while n>=0: print(\"iterasi saat X\"+str(n)) fx = x**2-5*x+6 fax = 2*x-5 x1 = x - (fx/fax) if abs(x1-x)<e or n>=100: print(\"Jumlah iterasi : \",n+1) print(x) break else: x=x1 # print(n) n+=1 Hasil run program : Masukkan nilai awal x : 1 iterasi saat X0 iterasi saat X1 iterasi saat X2 iterasi saat X3 iterasi saat X4 Jumlah iterasi : 5 1.9999847409781035","title":"Metode Newton Raphson"},{"location":"tugas2/#metode-secant","text":"\u25a0 Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). \u25a0 Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. \u25a0 Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen \u25a0 Modifikasi metode Newton Raphson dinamakan metode Secant. Rumus : Algoritma : Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x_0 dan x_1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x_0 ) dan fx_1 sebagai y_0 dan y_1 Untuk iterasi 1 s/d n x_(i+1)= x_i-(f(xi)(x_i \u3016-x\u3017 (i-1)))/(y_i - y (i-1) ) hitung y_(i+1)=\u3016f(x\u3017_(i+1)) Akar persamaan adalah nilai x yang terakhir Contoh program : #Secant def Secant(a,b,n): e = 0.001 fa = a**2-5*a+6 fb = b**2-5*b+6 # if fa*fb<0: x = a-((b-a)/(fb-fa))*fa fx = x**2-5*x+6 n+=1 print(\"iterasi ke-\"+str(n)) if abs(a-b)<e: print(\"Jumlah iterasi :\",n) print(x) else: a=b b=x Secant(a,b,n) # else: # if fa<fb: # a-=0.1 # elif fb<fa: # b+=0.1 # print(\"a\",a,\"and b\",b) # Secant(a,b) a = float(input(\"Masukkan nilai a : \")) b = float(input(\"Masukkan nilai b : \")) n = 0 Secant(a,b,0) Hasil run program : Masukkan nilai a : 1 Masukkan nilai b : 1.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 Jumlah iterasi : 6 1.9999999975499005","title":"Metode Secant"}]}