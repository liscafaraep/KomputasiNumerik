{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Komputasi Numerik . . Nama : Liscafara Eldyar Pratiwi NIM : 180411100034 Mata Kuliah : Komputasi Numerik 4B Dosen : Mulaab S.Si. M.Kom . . KUMPULAN TUGAS KOMPUTASI NUMERIK . . . Keep learn, learn, and learn. Never give up!:)","title":"Home"},{"location":"#komputasi-numerik","text":". . Nama : Liscafara Eldyar Pratiwi NIM : 180411100034 Mata Kuliah : Komputasi Numerik 4B Dosen : Mulaab S.Si. M.Kom . .","title":"Komputasi Numerik"},{"location":"#kumpulan-tugas-komputasi-numerik","text":". . . Keep learn, learn, and learn. Never give up!:)","title":"KUMPULAN TUGAS KOMPUTASI NUMERIK"},{"location":"Tugas-3/","text":"Tugas 3 Penyelesaian Sistem Persamaan Linier Menggunakan Metode Gauss Jordan, Gauss Jacobi, Gauss Seidel Eliminasi Gauss Jordan Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal. Algoritma Gauss Jordan Listing Program import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793 Eliminasi Gauss Jacobi Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an. Listing Program from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ]) Program Gauss Seidel Listing Program def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Tugas 3"},{"location":"Tugas-3/#tugas-3","text":"","title":"Tugas 3"},{"location":"Tugas-3/#penyelesaian-sistem-persamaan-linier-menggunakan-metode-gauss-jordan-gauss-jacobi-gauss-seidel","text":"","title":"Penyelesaian Sistem Persamaan Linier Menggunakan Metode Gauss Jordan, Gauss Jacobi, Gauss Seidel"},{"location":"Tugas-3/#eliminasi-gauss-jordan","text":"Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal.","title":"Eliminasi Gauss Jordan"},{"location":"Tugas-3/#algoritma-gauss-jordan","text":"","title":"Algoritma Gauss Jordan"},{"location":"Tugas-3/#_1","text":"","title":""},{"location":"Tugas-3/#listing-program","text":"import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793","title":"Listing Program"},{"location":"Tugas-3/#eliminasi-gauss-jacobi","text":"Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an.","title":"Eliminasi Gauss Jacobi"},{"location":"Tugas-3/#listing-program_1","text":"from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"Listing Program"},{"location":"Tugas-3/#program-gauss-seidel","text":"","title":"Program Gauss Seidel"},{"location":"Tugas-3/#listing-program_2","text":"def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Listing Program"},{"location":"tugas-4/","text":"Tugas 4 Integrasi Numerik A. Pengertian Integrasi Romberg merupakan teknik yang digunakan dalam integrasi numerik untuk menganalisis kasus dimana fungsi yang akan diintegrasikan tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan untuk mengembangkan skema yang efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson ( Richardson's extrapolation ), yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga, yang lebih akurat. Teknik ini bersifat rekursif dan dapat digunakan untuk menghasilkan sebuah perkiraan integral dalam batas toleransi kesalahan ( error tolerance ) yang sudah ditentukan terlebih dahulu. Metode ini digunakan untuk memperbaiki hasil pendekatan integrasi metode trapesium, karena kesalahan metode trapesium \u201ccukup\u201d besar untuk polinom untuk polinom pangkat tinggi dan fungsi transeden. Pada proses integrasi Romberg, mula-mula kita hitung kuadratur dengan lebar langkah h dan 2h. Defisini kuadratur adalah Untuk menurunkan galat hampiran integral dari O(h2) menjadi O(h2n + 2) dapat digunakan ekstrapolasi Richardson seperti dinyatakan dalam teorema : jika didefinisikan barisan kuadratur {I(i,j) : i >= j dimana j =1, 2, 3, ....} untuk hampiran integral f(x) pada [a, b] sebagai: \u200b I (i, 1) = Ti \u2013 1. i \u2265 1 ( barisan aturan trapezium majemuk) \u200b I (i, 2) = Si \u2013 1. i \u2265 2 (barisan aturan Simpson majemuk) \u200b I (i, 3) = Bi \u2013 1. i \u2265 3 (barisan aturan Boole majemuk) Maka integrasi romberg untuk meningkatkan keakuratan hampiran integral dapat di tulis sebagai B. Code Program import numpy as np def trapezcomp(f, a, b, n): \"\"\" Composite trapezoidal function integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound n: number of panels to create between ``a`` and ``b`` \"\"\" # Initialization h = (b - a) / n x = a # Composite rule In = f(a) for k in range(1, n): x = x + h In += 2*f(x) return (In + f(b))*h*0.5 def romberg(f, a, b, p): \"\"\" Romberg integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound p: number of rows in the Romberg table \"\"\" I = np.zeros((p, p)) for k in range(0, p): # Composite trapezoidal rule for 2^k panels I[k, 0] = trapezcomp(f, a, b, 2**k) # Romberg recursive formula for j in range(0, k): I[k, j+1] = (4**(j+1) * I[k, j] - I[k-1, j]) / (4**(j+1) - 1) print(I[k, 0:k+1]) # display intermediate results return I if __name__ == '__main__': def func(x): return np.sin(x) p_rows = 4 I = romberg(func, 0, np.pi/2, p_rows) solution = I[p_rows-1, p_rows-1] print(solution) # 1.00000000814 C. Output Microsoft Windows [Version 10.0.18362.657] (c) 2019 Microsoft Corporation. All rights reserved. C:\\Kuliah\\KomputasiNumerik>python romberg.py [0.78539816] [0.94805945 1.00227988] [0.9871158 1.00013458 0.99999157] [0.99678517 1.0000083 0.99999988 1.00000001] 1.0000000081440203","title":"Tugas 4"},{"location":"tugas-4/#tugas-4","text":"","title":"Tugas 4"},{"location":"tugas-4/#integrasi-numerik","text":"","title":"Integrasi Numerik"},{"location":"tugas-4/#a-pengertian","text":"Integrasi Romberg merupakan teknik yang digunakan dalam integrasi numerik untuk menganalisis kasus dimana fungsi yang akan diintegrasikan tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan untuk mengembangkan skema yang efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson ( Richardson's extrapolation ), yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga, yang lebih akurat. Teknik ini bersifat rekursif dan dapat digunakan untuk menghasilkan sebuah perkiraan integral dalam batas toleransi kesalahan ( error tolerance ) yang sudah ditentukan terlebih dahulu. Metode ini digunakan untuk memperbaiki hasil pendekatan integrasi metode trapesium, karena kesalahan metode trapesium \u201ccukup\u201d besar untuk polinom untuk polinom pangkat tinggi dan fungsi transeden. Pada proses integrasi Romberg, mula-mula kita hitung kuadratur dengan lebar langkah h dan 2h. Defisini kuadratur adalah Untuk menurunkan galat hampiran integral dari O(h2) menjadi O(h2n + 2) dapat digunakan ekstrapolasi Richardson seperti dinyatakan dalam teorema : jika didefinisikan barisan kuadratur {I(i,j) : i >= j dimana j =1, 2, 3, ....} untuk hampiran integral f(x) pada [a, b] sebagai: \u200b I (i, 1) = Ti \u2013 1. i \u2265 1 ( barisan aturan trapezium majemuk) \u200b I (i, 2) = Si \u2013 1. i \u2265 2 (barisan aturan Simpson majemuk) \u200b I (i, 3) = Bi \u2013 1. i \u2265 3 (barisan aturan Boole majemuk) Maka integrasi romberg untuk meningkatkan keakuratan hampiran integral dapat di tulis sebagai","title":"A. Pengertian"},{"location":"tugas-4/#b-code-program","text":"import numpy as np def trapezcomp(f, a, b, n): \"\"\" Composite trapezoidal function integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound n: number of panels to create between ``a`` and ``b`` \"\"\" # Initialization h = (b - a) / n x = a # Composite rule In = f(a) for k in range(1, n): x = x + h In += 2*f(x) return (In + f(b))*h*0.5 def romberg(f, a, b, p): \"\"\" Romberg integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound p: number of rows in the Romberg table \"\"\" I = np.zeros((p, p)) for k in range(0, p): # Composite trapezoidal rule for 2^k panels I[k, 0] = trapezcomp(f, a, b, 2**k) # Romberg recursive formula for j in range(0, k): I[k, j+1] = (4**(j+1) * I[k, j] - I[k-1, j]) / (4**(j+1) - 1) print(I[k, 0:k+1]) # display intermediate results return I if __name__ == '__main__': def func(x): return np.sin(x) p_rows = 4 I = romberg(func, 0, np.pi/2, p_rows) solution = I[p_rows-1, p_rows-1] print(solution) # 1.00000000814","title":"B. Code Program"},{"location":"tugas-4/#c-output","text":"Microsoft Windows [Version 10.0.18362.657] (c) 2019 Microsoft Corporation. All rights reserved. C:\\Kuliah\\KomputasiNumerik>python romberg.py [0.78539816] [0.94805945 1.00227988] [0.9871158 1.00013458 0.99999157] [0.99678517 1.0000083 0.99999988 1.00000001] 1.0000000081440203","title":"C. Output"},{"location":"tugas1/","text":"Eror (Galat) pada Komputasi Numerik Pengertian Galat Error/Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. Masalah-masalah matematika yang sering kita selesaikan biasanya menggunakan metode analitik atau metode sejati, yaitu suatu metode yang memberikan solusi yang sesungguhnya, karena memiliki galat ( error ) yang bernilai nol. Tetapi penyelesaian dengan menggunakan metode analitik hanya terbatas , tidak selalu bisa diterapkan , maka solusinya masih dapat dicari yaitu dengan menggunakan metode numerik. Pada metode numerik solusinya merupakan hampiran (pendekatan) terhadap solusi sejati. Nilai Galat (Nilai Kesalahan) Besarnya kesalahan atas suatu nilai taksiran dapat dinyatakan secara kuantitatif dan kualitatif. Besarnya kesalahan yang dinyatakan secara kuantitatif disebut Kesalahan Absolut. Besarnya kesalahan yang dinyatakan secara kualitatif disebut dengan Kesalahan Relatif . Absolute Error Kesalahan absolut suatu kuantitas adalah nilai absolut dari selisih antara nilai sebenarnya X dan nilai perkiraan x. Ini dilambangkan dengan : \ud835\udc38\ud835\udc34 =|\ud835\udc4b\u2212 \ud835\udc65| Contoh sederhana : Nilai perkiraan \u1d2b adalah 3.1428571 dan nilai sebenarnya adalah 3.1415926. Temukan Kesalahan absolut \ud835\udc38\ud835\udc34 =|\ud835\udc4b\u2212 \ud835\udc65|= |3.1415926\u2212 3.1428571| \u200b = |\u2212 0 .0 0 1 2 6 4 5| = 0 .0 0 1 2 6 4 5 Relative Error Kesalahan relatif dari suatu kuantitas adalah rasio kesalahan absolutnya terhadap nilai sebenarnya. Ini dilambangkan dengan Er = |(XT-XA)/XT| Contoh (dari soal sebelumnya) : \ud835\udc38R = |3.1415926\u2212 3.1428571/3.1415926 | = | -0.0004025 | = 0.0004025 Persentase relative error: Er = |(XT-XA)/XT|*100% sumber kesalahan dalam komputasi numerik. A. Round off errors Kesalahan jenis ini terjadi akibat proses pembulatan dalam perhitungan. Secara umum, proses pembulatan ada 2 aturan yaitu : - Jika digit yang dibulatkan kurang dari 5, maka tidak terjadi pembulatan. - Sebaliknya, jika lebih dari 5, maka terjadi pembulatan yaitu dengan menambah satu. Contoh sederhananya adalah sebagai berikut : Pada perhitungan nilai x = 6/7, maka nilai x = 0,857142857143. Maka, jika terjadi pembulatan akan diperoleh nilai sebagai berikut : \u00e8 x = 0,86 ( mendekati nilai 2 desimal ). \u00e8 x = 0,8571 ( mendekati nilai 4 desimal ). \u00e8 x = 0,857143 ( mendekati nilai 6 desimal ). \u00e8 x = 0,85714286 ( mendekati nilai 8 desimal ). Dalam proses pembuatan, kesalahan yang timbul akibat pembulatan pada digit ke- n di belakang koma selalu bernilai : Dengan begitu, maka : \u00e8 Untuk x = 0,86 (n = 2), maka Error = | 0,857142857143 \u2013 0,86 | = 0,00285714286 Dengan begitu terbukti bahwa Error \u2264 10-4/2 <-> 0,00285714286 \u2264 0,005. \u00e8 Untuk x = 0,8571 (n = 4), maka Error = | 0,857142857143 \u2013 0,8571 | = 0,000042857143 Dengan begitu terbukti bahwa Error \u2264 10-4/2 <-> Error \u2264 0,00005. \u00e8 Dan seterusnya. ( Anda bisa membuktikan untuk x = 0,857143 dan x = 0,85714286. ) Kesalahan ini biasanya digunakan pada perhitungan data dari hasil percobaan praktikum seperti perhitungan nilai gravitasi dengan teknik perhitungan bandul, menentukan nilai tegangan permukaan, dan lain \u2013 lain. Masing \u2013 masing percobaan biasanya mengulang sebanyak 5 \u2013 10 kali dengan tujuan untuk mengetahui kesalahan mutlak dan mengetahui apakah data yang diperoleh dari hasil praktikum itu tepat, teliti, masih ada kesalahan, atau bahkan error-nya sangat jauh dari perhitungan berdasarkan formula. Teknik ini adalah aprosikmasi kesalahan ( dibahas di bagian blog Aprosikmasi Kesalahan ). Disinilah kegunaan untuk menentukan error suatu perhitungan dengan teknik ini. B. Truncation errors Kesalahan pemotongan biasanya terjadi karena pembuangan suku yang berderajat tinggi. Sebagai contoh untuk menghitung nilai cosinus dapat menggunakan deret Taylor yang dirumuskan di bawah ini : Karena batas akhirnya tak hingga, maka dilakukan pemotongan suku agar perhitungannya lebih sederhana. Misalkan menentukan nilai sin(20) = 0.9129452507276277. Dengan deret Taylor ( hampir sama dengan konsep perhitungan nilai cos ) sampain = 100 akan diperoleh : Dengan begitu nilai errornya adalah C. Range errors Kesalahan yang terjadi akibat nilai hasil komputasi melampaui batas angka yang diperbolehkan dalam komputer. Misalkan dalam penggunaan variabel integer pada proses perhitungan energi benda hitam yang menghasilkan nilai yang tidak tepat bahkan tidak terdefinisi. Untuk kesalahan ini berkaitan dengan batas dalam jangkauan representasi angka. Ini bisa dikatakan bahwa jika hasil perhitungan melebihi jangkauan, maka komputer akan menampilkan hasil yang tidak beraturan ( anggap saja hasil yang diperoleh diatur lagi oleh OS yang kita pakai ). Soal Buat program untuk menentukan jumlah suku agar eror yang tercipta mencapai 0,001 dan cari nilai yang paling mendekati dengan nilai sesungguhnya sesuai selisih tersebut! Program f(x) = e**3x import math x = 1 i = 1 f = 1 #e = (a**i)*x**i #h = abs(f-e) #print(i) while i>0: e = ((2**1)*x**i)/math.factorial(i) f1 = f+e #print(f1) h = abs(f-f1) #ini selisih print(\"Iterasi ke-\"+str(i)) print(\"Selisih =\",h) if h<=0.001: break else: f+=e i+=1 print(\"Jumlah iterasi =\",i) Output yang dihasilkan : Iterasi ke-1 Selisih = 2.0 Iterasi ke-2 Selisih = 1.0 Iterasi ke-3 Selisih = 0.33333333333333304 Iterasi ke-4 Selisih = 0.08333333333333304 Iterasi ke-5 Selisih = 0.016666666666666607 Iterasi ke-6 Selisih = 0.002777777777778212 Iterasi ke-7 Selisih = 0.0003968253968258395 Jumlah iterasi = 7 Referensi : http://algokelvinht.blogspot.com/2016/12/komputer-numerik-galat-atau-error-003.html Ppt : \"Error in Numerical Computations\"","title":"Tugas 1"},{"location":"tugas1/#eror-galat-pada-komputasi-numerik","text":"","title":"Eror (Galat) pada Komputasi Numerik"},{"location":"tugas1/#pengertian-galat","text":"Error/Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. Masalah-masalah matematika yang sering kita selesaikan biasanya menggunakan metode analitik atau metode sejati, yaitu suatu metode yang memberikan solusi yang sesungguhnya, karena memiliki galat ( error ) yang bernilai nol. Tetapi penyelesaian dengan menggunakan metode analitik hanya terbatas , tidak selalu bisa diterapkan , maka solusinya masih dapat dicari yaitu dengan menggunakan metode numerik. Pada metode numerik solusinya merupakan hampiran (pendekatan) terhadap solusi sejati.","title":"Pengertian Galat"},{"location":"tugas1/#nilai-galat-nilai-kesalahan","text":"Besarnya kesalahan atas suatu nilai taksiran dapat dinyatakan secara kuantitatif dan kualitatif. Besarnya kesalahan yang dinyatakan secara kuantitatif disebut Kesalahan Absolut. Besarnya kesalahan yang dinyatakan secara kualitatif disebut dengan Kesalahan Relatif .","title":"Nilai Galat (Nilai Kesalahan)"},{"location":"tugas1/#absolute-error","text":"Kesalahan absolut suatu kuantitas adalah nilai absolut dari selisih antara nilai sebenarnya X dan nilai perkiraan x. Ini dilambangkan dengan : \ud835\udc38\ud835\udc34 =|\ud835\udc4b\u2212 \ud835\udc65| Contoh sederhana : Nilai perkiraan \u1d2b adalah 3.1428571 dan nilai sebenarnya adalah 3.1415926. Temukan Kesalahan absolut \ud835\udc38\ud835\udc34 =|\ud835\udc4b\u2212 \ud835\udc65|= |3.1415926\u2212 3.1428571| \u200b = |\u2212 0 .0 0 1 2 6 4 5| = 0 .0 0 1 2 6 4 5","title":"Absolute Error"},{"location":"tugas1/#relative-error","text":"Kesalahan relatif dari suatu kuantitas adalah rasio kesalahan absolutnya terhadap nilai sebenarnya. Ini dilambangkan dengan Er = |(XT-XA)/XT| Contoh (dari soal sebelumnya) : \ud835\udc38R = |3.1415926\u2212 3.1428571/3.1415926 | = | -0.0004025 | = 0.0004025 Persentase relative error: Er = |(XT-XA)/XT|*100% sumber kesalahan dalam komputasi numerik. A. Round off errors Kesalahan jenis ini terjadi akibat proses pembulatan dalam perhitungan. Secara umum, proses pembulatan ada 2 aturan yaitu : - Jika digit yang dibulatkan kurang dari 5, maka tidak terjadi pembulatan. - Sebaliknya, jika lebih dari 5, maka terjadi pembulatan yaitu dengan menambah satu. Contoh sederhananya adalah sebagai berikut : Pada perhitungan nilai x = 6/7, maka nilai x = 0,857142857143. Maka, jika terjadi pembulatan akan diperoleh nilai sebagai berikut : \u00e8 x = 0,86 ( mendekati nilai 2 desimal ). \u00e8 x = 0,8571 ( mendekati nilai 4 desimal ). \u00e8 x = 0,857143 ( mendekati nilai 6 desimal ). \u00e8 x = 0,85714286 ( mendekati nilai 8 desimal ). Dalam proses pembuatan, kesalahan yang timbul akibat pembulatan pada digit ke- n di belakang koma selalu bernilai : Dengan begitu, maka : \u00e8 Untuk x = 0,86 (n = 2), maka Error = | 0,857142857143 \u2013 0,86 | = 0,00285714286 Dengan begitu terbukti bahwa Error \u2264 10-4/2 <-> 0,00285714286 \u2264 0,005. \u00e8 Untuk x = 0,8571 (n = 4), maka Error = | 0,857142857143 \u2013 0,8571 | = 0,000042857143 Dengan begitu terbukti bahwa Error \u2264 10-4/2 <-> Error \u2264 0,00005. \u00e8 Dan seterusnya. ( Anda bisa membuktikan untuk x = 0,857143 dan x = 0,85714286. ) Kesalahan ini biasanya digunakan pada perhitungan data dari hasil percobaan praktikum seperti perhitungan nilai gravitasi dengan teknik perhitungan bandul, menentukan nilai tegangan permukaan, dan lain \u2013 lain. Masing \u2013 masing percobaan biasanya mengulang sebanyak 5 \u2013 10 kali dengan tujuan untuk mengetahui kesalahan mutlak dan mengetahui apakah data yang diperoleh dari hasil praktikum itu tepat, teliti, masih ada kesalahan, atau bahkan error-nya sangat jauh dari perhitungan berdasarkan formula. Teknik ini adalah aprosikmasi kesalahan ( dibahas di bagian blog Aprosikmasi Kesalahan ). Disinilah kegunaan untuk menentukan error suatu perhitungan dengan teknik ini. B. Truncation errors Kesalahan pemotongan biasanya terjadi karena pembuangan suku yang berderajat tinggi. Sebagai contoh untuk menghitung nilai cosinus dapat menggunakan deret Taylor yang dirumuskan di bawah ini : Karena batas akhirnya tak hingga, maka dilakukan pemotongan suku agar perhitungannya lebih sederhana. Misalkan menentukan nilai sin(20) = 0.9129452507276277. Dengan deret Taylor ( hampir sama dengan konsep perhitungan nilai cos ) sampain = 100 akan diperoleh : Dengan begitu nilai errornya adalah C. Range errors Kesalahan yang terjadi akibat nilai hasil komputasi melampaui batas angka yang diperbolehkan dalam komputer. Misalkan dalam penggunaan variabel integer pada proses perhitungan energi benda hitam yang menghasilkan nilai yang tidak tepat bahkan tidak terdefinisi. Untuk kesalahan ini berkaitan dengan batas dalam jangkauan representasi angka. Ini bisa dikatakan bahwa jika hasil perhitungan melebihi jangkauan, maka komputer akan menampilkan hasil yang tidak beraturan ( anggap saja hasil yang diperoleh diatur lagi oleh OS yang kita pakai ).","title":"Relative Error"},{"location":"tugas1/#soal","text":"Buat program untuk menentukan jumlah suku agar eror yang tercipta mencapai 0,001 dan cari nilai yang paling mendekati dengan nilai sesungguhnya sesuai selisih tersebut!","title":"Soal"},{"location":"tugas1/#program","text":"f(x) = e**3x import math x = 1 i = 1 f = 1 #e = (a**i)*x**i #h = abs(f-e) #print(i) while i>0: e = ((2**1)*x**i)/math.factorial(i) f1 = f+e #print(f1) h = abs(f-f1) #ini selisih print(\"Iterasi ke-\"+str(i)) print(\"Selisih =\",h) if h<=0.001: break else: f+=e i+=1 print(\"Jumlah iterasi =\",i) Output yang dihasilkan : Iterasi ke-1 Selisih = 2.0 Iterasi ke-2 Selisih = 1.0 Iterasi ke-3 Selisih = 0.33333333333333304 Iterasi ke-4 Selisih = 0.08333333333333304 Iterasi ke-5 Selisih = 0.016666666666666607 Iterasi ke-6 Selisih = 0.002777777777778212 Iterasi ke-7 Selisih = 0.0003968253968258395 Jumlah iterasi = 7 Referensi : http://algokelvinht.blogspot.com/2016/12/komputer-numerik-galat-atau-error-003.html Ppt : \"Error in Numerical Computations\"","title":"Program"},{"location":"tugas2/","text":"Tugas 2 Solusi Numerik untuk Persamaan Non Linier Penyelesaian persamaan non linier adalah penentuan akar-akar persamaan non linier. Akar sebuah persamaan f(x) =0 adalah nilai-nilai x yang menyebabkan nilai f(x) sama dengan nol. Akar persamaan f(x) adalah titik potong antara kurva f(x) dan sumbu X. Penyelesaian persamaan nonlinier Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant. Soal Selesaikan persamaan non linier menggunakan metode numerik! $$ x^2-5x+6 $$ Metode Bisection Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma : 1.Definisikan fungsi f(x) yang akan dicari akarnya 2.Tentukan nilai a dan b 3.Tentukan toleransi e dan iterasi maksimum N 4.Hitung f(a) dan f(b) 5.Jika f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan 6.Hitung x = (a+b)/2 7.Hitung f(x) 8.Bila f(x).f(a)<0 maka b = x dan f(b)=f(x), bila tidak maka a=x dan f(a)=f(x) 9.Jika |b-a| iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Contoh program : #Bisection def bis(a,b,n): e = 0.001 fa = a**2-5*a+6 fb = b**2-5*b+6 if fa*fb<0: x = (a+b)/2 fx = x**2-5*x+6 if fa*fx<0: b = x elif fx*fb<0: a = x # print(a) # print(b) if abs(a-b)<e: print(\"Jumlah Iterasi : \",n) print(x) else: n+=1 print(\"iterasi ke-\"+str(n)) bis(a,b,n) else: if fa<fb: a-=0.1 elif fb<fa: b+=0.1 # print(\"a\",a,\"and b\",b) bis(a,b,n) a = float(input(\"Masukkan nilai a : \")) b = float(input(\"Masukkan nilai b : \")) bis(a,b,0) Hasil run program : Masukkan nilai a : 1 Masukkan nilai b : 2.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 iterasi ke-7 iterasi ke-8 iterasi ke-9 iterasi ke-10 Jumlah Iterasi : 10 1.999755859375 Metode Regula Falsi Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurna dari metode bisection Algoritma : Definisikan fungsi f(x) Tentukan batas bawah (a) dan batas atas (b) Tentukan toleransi error e Hitung f(a) dan f(b) Untuk iterasi 1 s/d n > e : c= (f(b).a -f(a).b)/(f(b)-f(a)) Hitung f(c)=f(x) Hitung error = |f(c)| Jika f(c).f(a)<0 maka nilai a tetap ,jika tidak maka a=c dan f(a)=f(c) Akar persamaanya = c Contoh program : #Regula-Falsi def Regfal(a,b,n): e = 0.001 fa = a**2-5*a+6 fb = b**2-5*b+6 # print(fa*fb) if fa*fb<0: n+=1 print(\"iterasi ke-\"+str(n)) # print(\"jalan\") x = ((a*abs(fb))+(b*abs(fa)))/(abs(fa)+abs(fb)) fx = x**2-5*x+6 # print(fx) # print(fb) if fa*fx<0: b = x # elif fb*fx<0: else: a = x # print(a) # print(b) # print(abs(a-b)) if abs(a-b)<e: print(x) else: Regfal(a,b,n) else: if fa<fb: a-=0.1 else: b+=0.1 Regfal(a,b,n) a = float(input(\"Masukkan interval a : \")) b = float(input(\"Masukkan interval b : \")) Regfal(a,b,0) Hasil run program : Masukkan interval a : 1.5 Masukkan interval b : 2.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 iterasi ke-7 iterasi ke-8 iterasi ke-9 iterasi ke-10 iterasi ke-11 iterasi ke-12 iterasi ke-13 iterasi ke-14 iterasi ke-15 iterasi ke-16 iterasi ke-17 iterasi ke-18 iterasi ke-19 iterasi ke-20 iterasi ke-21 iterasi ke-22 iterasi ke-23 iterasi ke-24 iterasi ke-25 iterasi ke-26 iterasi ke-27 iterasi ke-28 iterasi ke-29 iterasi ke-30 iterasi ke-31 iterasi ke-32 2.0 Metode Newton Raphson Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurna dari metode bisection. Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Rumus : $$ x1=x0-(f(x0))/(f\u2032(x0)) $$ Contoh program : #Newton-Raphson x = float(input(\"Masukkan nilai awal x : \")) n = 0 e = 0.001 while n>=0: print(\"iterasi saat X\"+str(n)) fx = x**2-5*x+6 fax = 2*x-5 x1 = x - (fx/fax) if abs(x1-x)<e or n>=100: print(\"Jumlah iterasi : \",n+1) print(x) break else: x=x1 # print(n) n+=1 Hasil run program : Masukkan nilai awal x : 1 iterasi saat X0 iterasi saat X1 iterasi saat X2 iterasi saat X3 iterasi saat X4 Jumlah iterasi : 5 1.9999847409781035 Metode Secant \u25a0 Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). \u25a0 Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. \u25a0 Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen \u25a0 Modifikasi metode Newton Raphson dinamakan metode Secant. Rumus : Algoritma : Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x_0 dan x_1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x_0 ) dan fx_1 sebagai y_0 dan y_1 Untuk iterasi 1 s/d n x_(i+1)= x_i-(f(xi)(x_i \u3016-x\u3017 (i-1)))/(y_i - y (i-1) ) hitung y_(i+1)=\u3016f(x\u3017_(i+1)) Akar persamaan adalah nilai x yang terakhir Contoh program : #Secant def Secant(a,b,n): e = 0.001 fa = a**2-5*a+6 fb = b**2-5*b+6 # if fa*fb<0: x = a-((b-a)/(fb-fa))*fa fx = x**2-5*x+6 n+=1 print(\"iterasi ke-\"+str(n)) if abs(a-b)<e: print(\"Jumlah iterasi :\",n) print(x) else: a=b b=x Secant(a,b,n) # else: # if fa<fb: # a-=0.1 # elif fb<fa: # b+=0.1 # print(\"a\",a,\"and b\",b) # Secant(a,b) a = float(input(\"Masukkan nilai a : \")) b = float(input(\"Masukkan nilai b : \")) n = 0 Secant(a,b,0) Hasil run program : Masukkan nilai a : 1 Masukkan nilai b : 1.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 Jumlah iterasi : 6 1.9999999975499005","title":"Tugas 2"},{"location":"tugas2/#tugas-2","text":"","title":"Tugas 2"},{"location":"tugas2/#solusi-numerik-untuk-persamaan-non-linier","text":"Penyelesaian persamaan non linier adalah penentuan akar-akar persamaan non linier. Akar sebuah persamaan f(x) =0 adalah nilai-nilai x yang menyebabkan nilai f(x) sama dengan nol. Akar persamaan f(x) adalah titik potong antara kurva f(x) dan sumbu X.","title":"Solusi Numerik untuk Persamaan Non Linier"},{"location":"tugas2/#penyelesaian-persamaan-nonlinier","text":"Metode Tertutup Mencari akar pada range [a,b] tertentu Dalam range[a,b] dipastikan terdapat satu akar Hasil selalu konvergen \u2192 disebut juga metode konvergen Contohnya Metode Tabel ,Metode Biseksi,Metode Regula Falsi Metode Terbuka Diperlukan tebakan awal xn dipakai untuk menghitung xn+1 Hasil dapat konvergen atau divergen Contohnya Metode Iterasi Sederhana, Metode Newton-Raphson, Metode Secant.","title":"Penyelesaian persamaan nonlinier"},{"location":"tugas2/#soal","text":"Selesaikan persamaan non linier menggunakan metode numerik! $$ x^2-5x+6 $$","title":"Soal"},{"location":"tugas2/#metode-bisection","text":"Metode biseksi ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma : 1.Definisikan fungsi f(x) yang akan dicari akarnya 2.Tentukan nilai a dan b 3.Tentukan toleransi e dan iterasi maksimum N 4.Hitung f(a) dan f(b) 5.Jika f(a).f(b)>0 maka proses dihentikan karena tidak ada akar, bila tidak maka dilanjutkan 6.Hitung x = (a+b)/2 7.Hitung f(x) 8.Bila f(x).f(a)<0 maka b = x dan f(b)=f(x), bila tidak maka a=x dan f(a)=f(x) 9.Jika |b-a| iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Contoh program : #Bisection def bis(a,b,n): e = 0.001 fa = a**2-5*a+6 fb = b**2-5*b+6 if fa*fb<0: x = (a+b)/2 fx = x**2-5*x+6 if fa*fx<0: b = x elif fx*fb<0: a = x # print(a) # print(b) if abs(a-b)<e: print(\"Jumlah Iterasi : \",n) print(x) else: n+=1 print(\"iterasi ke-\"+str(n)) bis(a,b,n) else: if fa<fb: a-=0.1 elif fb<fa: b+=0.1 # print(\"a\",a,\"and b\",b) bis(a,b,n) a = float(input(\"Masukkan nilai a : \")) b = float(input(\"Masukkan nilai b : \")) bis(a,b,0) Hasil run program : Masukkan nilai a : 1 Masukkan nilai b : 2.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 iterasi ke-7 iterasi ke-8 iterasi ke-9 iterasi ke-10 Jumlah Iterasi : 10 1.999755859375","title":"Metode Bisection"},{"location":"tugas2/#metode-regula-falsi","text":"Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurna dari metode bisection Algoritma : Definisikan fungsi f(x) Tentukan batas bawah (a) dan batas atas (b) Tentukan toleransi error e Hitung f(a) dan f(b) Untuk iterasi 1 s/d n > e : c= (f(b).a -f(a).b)/(f(b)-f(a)) Hitung f(c)=f(x) Hitung error = |f(c)| Jika f(c).f(a)<0 maka nilai a tetap ,jika tidak maka a=c dan f(a)=f(c) Akar persamaanya = c Contoh program : #Regula-Falsi def Regfal(a,b,n): e = 0.001 fa = a**2-5*a+6 fb = b**2-5*b+6 # print(fa*fb) if fa*fb<0: n+=1 print(\"iterasi ke-\"+str(n)) # print(\"jalan\") x = ((a*abs(fb))+(b*abs(fa)))/(abs(fa)+abs(fb)) fx = x**2-5*x+6 # print(fx) # print(fb) if fa*fx<0: b = x # elif fb*fx<0: else: a = x # print(a) # print(b) # print(abs(a-b)) if abs(a-b)<e: print(x) else: Regfal(a,b,n) else: if fa<fb: a-=0.1 else: b+=0.1 Regfal(a,b,n) a = float(input(\"Masukkan interval a : \")) b = float(input(\"Masukkan interval b : \")) Regfal(a,b,0) Hasil run program : Masukkan interval a : 1.5 Masukkan interval b : 2.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 iterasi ke-7 iterasi ke-8 iterasi ke-9 iterasi ke-10 iterasi ke-11 iterasi ke-12 iterasi ke-13 iterasi ke-14 iterasi ke-15 iterasi ke-16 iterasi ke-17 iterasi ke-18 iterasi ke-19 iterasi ke-20 iterasi ke-21 iterasi ke-22 iterasi ke-23 iterasi ke-24 iterasi ke-25 iterasi ke-26 iterasi ke-27 iterasi ke-28 iterasi ke-29 iterasi ke-30 iterasi ke-31 iterasi ke-32 2.0","title":"Metode Regula Falsi"},{"location":"tugas2/#metode-newton-raphson","text":"Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position. Metode ini juga merupakan penyempurna dari metode bisection. Metode Newton-Raphson adalah metode pencarian akar suatu fungsi f(x) dengan pendekatan satu titik, dimana fungsi f(x) mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Rumus : $$ x1=x0-(f(x0))/(f\u2032(x0)) $$ Contoh program : #Newton-Raphson x = float(input(\"Masukkan nilai awal x : \")) n = 0 e = 0.001 while n>=0: print(\"iterasi saat X\"+str(n)) fx = x**2-5*x+6 fax = 2*x-5 x1 = x - (fx/fax) if abs(x1-x)<e or n>=100: print(\"Jumlah iterasi : \",n+1) print(x) break else: x=x1 # print(n) n+=1 Hasil run program : Masukkan nilai awal x : 1 iterasi saat X0 iterasi saat X1 iterasi saat X2 iterasi saat X3 iterasi saat X4 Jumlah iterasi : 5 1.9999847409781035","title":"Metode Newton Raphson"},{"location":"tugas2/#metode-secant","text":"\u25a0 Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). \u25a0 Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. \u25a0 Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen \u25a0 Modifikasi metode Newton Raphson dinamakan metode Secant. Rumus : Algoritma : Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x_0 dan x_1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x_0 ) dan fx_1 sebagai y_0 dan y_1 Untuk iterasi 1 s/d n x_(i+1)= x_i-(f(xi)(x_i \u3016-x\u3017 (i-1)))/(y_i - y (i-1) ) hitung y_(i+1)=\u3016f(x\u3017_(i+1)) Akar persamaan adalah nilai x yang terakhir Contoh program : #Secant def Secant(a,b,n): e = 0.001 fa = a**2-5*a+6 fb = b**2-5*b+6 # if fa*fb<0: x = a-((b-a)/(fb-fa))*fa fx = x**2-5*x+6 n+=1 print(\"iterasi ke-\"+str(n)) if abs(a-b)<e: print(\"Jumlah iterasi :\",n) print(x) else: a=b b=x Secant(a,b,n) # else: # if fa<fb: # a-=0.1 # elif fb<fa: # b+=0.1 # print(\"a\",a,\"and b\",b) # Secant(a,b) a = float(input(\"Masukkan nilai a : \")) b = float(input(\"Masukkan nilai b : \")) n = 0 Secant(a,b,0) Hasil run program : Masukkan nilai a : 1 Masukkan nilai b : 1.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 Jumlah iterasi : 6 1.9999999975499005","title":"Metode Secant"},{"location":"tugas5/","text":"Richardson Extrapolation Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Teori Dalam rumus : ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K h n + o(h n ) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n h n + o(h n ) Mengalikan kedua ekspresi ini dengan 2 n dan mengurangi hasil persamaan pertama 2n e \u2212 e = 2na(h/2) \u2212 a(h) + K/2n h n \u2212 K h n + o(h n ) Perhatikan bahwa istilah h n dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(h n ) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knh n . Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h 2 , etc. Contoh Program from math import * def zeros(n,m): Z=[] for i in range(n): Z.append([0]*m) return Z def D(Func,a,h): return (Func(a+h)-Func(a-h))/(2*h) def Richardson_dif(func,a): '''Richardson extrapolation method for numerical calculation of first derivative ''' k=9 L=zeros(k,k) for I in range(k): L[I][0]=D(func,a,1/(2**(I+1))) for j in range(1,k): for i in range(k-j): L[i][j]=((4**(j))*L[i+1][j-1]-L[i][j-1])/(4**(j)-1) return L[0][k-1] print('DIFERENSIASI NUMERIK DARI') print('f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5') print('%04.20f'%Richardson_dif(lambda x: -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 ,0.5)) print('diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f'%Richardson_dif(lambda x: 2**cos(pi+sin(x)),pi/3)) Hasil Running DIFERENSIASI NUMERIK DARI f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5 -0.91250000000000530687 diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = 0.16849558398154249050 >>>","title":"Tugas 5"},{"location":"tugas5/#richardson-extrapolation","text":"Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa.","title":"Richardson Extrapolation"},{"location":"tugas5/#teori","text":"Dalam rumus : ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K h n + o(h n ) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n h n + o(h n ) Mengalikan kedua ekspresi ini dengan 2 n dan mengurangi hasil persamaan pertama 2n e \u2212 e = 2na(h/2) \u2212 a(h) + K/2n h n \u2212 K h n + o(h n ) Perhatikan bahwa istilah h n dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(h n ) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knh n . Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h 2 , etc.","title":"Teori"},{"location":"tugas5/#contoh-program","text":"from math import * def zeros(n,m): Z=[] for i in range(n): Z.append([0]*m) return Z def D(Func,a,h): return (Func(a+h)-Func(a-h))/(2*h) def Richardson_dif(func,a): '''Richardson extrapolation method for numerical calculation of first derivative ''' k=9 L=zeros(k,k) for I in range(k): L[I][0]=D(func,a,1/(2**(I+1))) for j in range(1,k): for i in range(k-j): L[i][j]=((4**(j))*L[i+1][j-1]-L[i][j-1])/(4**(j)-1) return L[0][k-1] print('DIFERENSIASI NUMERIK DARI') print('f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5') print('%04.20f'%Richardson_dif(lambda x: -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 ,0.5)) print('diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f'%Richardson_dif(lambda x: 2**cos(pi+sin(x)),pi/3))","title":"Contoh Program"},{"location":"tugas5/#hasil-running","text":"DIFERENSIASI NUMERIK DARI f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5 -0.91250000000000530687 diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = 0.16849558398154249050 >>>","title":"Hasil Running"}]}